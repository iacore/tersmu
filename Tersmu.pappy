-- vim:ft=haskell
parser tersmu:

{
import JboSyntax
import FOL hiding (Term,Connective)

import Data.Maybe
import Control.Monad.State
import Data.Map (Map)
import qualified Data.Map as Map
}

top atext1
-- top term
-- top CMENE
-- top LojbanLetter

atext1 :: {[Statement]}
    = Spacing? ss:text1 !Char -> ss

text1 :: {[Statement]}
    = ((I lcon:jek? BO? -> lcon)+ -> {()} / NIhO+ -> {()})?
	ssm:(paragraphs)? -> {fromMaybe [] ssm}

paragraphs :: {[Statement]}
    = ss:paragraph ssm:(NIhO+ free* ss':paragraphs -> ss')?
	-> {ss ++ fromMaybe [] ssm}

paragraph :: {[Statement]}
    = s:statement ss:(I s:statement -> s)*
	-> {(s:ss)}

statement :: Statement
    = s:statement1 -> {Statement [] s}
    / ps:prenex {Statement ps' s}:statement ->
	{Statement (ps++ps') s}

statement1 :: Statement1
    = s:statement2 jekss:(_jekstatements)*
    -> { foldl (\s1 -> \(con,s2) -> ConnectedStatement con s1 s2) s jekss }
-- _jekstatements: helper for statement1
_jekstatements :: {(Connective, Statement1)}
    = I lcon:jek s:statement2 -> {(JboConnLog Nothing lcon,s)}

statement2 :: Statement1
    = s1:statement3 jeks:( I mlcon:(jek)? mtag:(tag)? BO s:statement2
	    -> {(JboConnLog mtag $ fromMaybe (LogJboConnective True 'e' True) mlcon,s)} )?
	-> { if (isNothing jeks) then s1
				 else (let Just (con,s2) = jeks
				       in ConnectedStatement con s1 s2) }

statement3 :: Statement1
    = {(ts,bt)}:sentence -> {StatementSentence (Sentence ts bt)}
    / TUhE ss:text1 TUhU? -> {StatementStatements ss}

asubsentence :: Subsentence
    = Spacing? subs:subsentence !Char -> subs

subsentence :: Subsentence
    = {(ts,bt)}:sentence -> {Subsentence [] (Sentence ts bt)}
    / ps:prenex {Subsentence ps' s}:subsentence ->
	{ Subsentence (ps++ps') s }

prenex :: {[Term]} = ps:terms ZOhU -> ps

sentence :: {([Term], BridiTail)}
    = mts1:(ts:terms CU? -> ts)?
	bt:bridiTail
	-> { (fromMaybe [] mts1, bt) }

terms :: {[Term]} = terms1+
terms1 :: Term 
    = ts1:terms2 PEhE lcon:jek ts2:terms2 -> { ConnectedTerms False (JboConnLog Nothing lcon) ts1 ts2 }
    / terms2
terms2 :: Term
    = t:term ts:(CEhE t:terms2 -> t)+ -> { Termset (t:ts) }
    / term

term :: Term = s:sumti -> {Sumti Untagged s}
	    / tag:tag s:sumti -> {Sumti (Tagged tag) s}
	    / n:tagFA s:sumti -> {Sumti (FATagged n) s}
	    / termset
	    / NA KU -> {Negation}
	    / tag:tag KU -> {BareTag tag}

termset :: Term
    = NUhI pcon:gek ts1:terms NUhU b:gik ts2:terms NUhU?
	-> { ConnectedTerms True (pcon b) (Termset ts1) (Termset ts2) }
    / NUhI ts:terms NUhU? -> { Termset ts }
    -- TODO: gek-termset

sumti :: Sumti =
    s:sumti1 rels:(VUhO rels:relativeClauses -> rels)?
	-> {
	    case rels of Nothing -> s
		         Just rels -> appendRelsToSumti rels s }


sumti1 :: Sumti = s1:sumti2
    eks:( lcon:ek mtag:(tag)? KE s:sumti
	(KEhE -> {()})? -> {(JboConnLog mtag lcon,s)} )?
    -> { if (isNothing eks) then s1
			    else (let Just (con,s2) = eks in
				      ConnectedSumti False con s1 s2 []) }

sumti2 :: Sumti = s:sumti3 ekss:(_eksumti)*
    -> { foldl (\s1 -> \(con,s2) -> ConnectedSumti False con s1 s2 []) s ekss }
-- _eksumti: helper for sumti2
_eksumti :: {(Connective, Sumti)}
    = lcon:ek s:sumti3 -> {(JboConnLog Nothing lcon,s)}

sumti3 :: Sumti = s1:sumti4
	eks:( lcon:ek mtag:(tag)? BO s:sumti3 -> {(JboConnLog mtag lcon,s)} )?
	    -> { if (isNothing eks) then s1
				    else (let Just (con,s2) = eks in
					      ConnectedSumti False con s1 s2 []) }

sumti4 :: Sumti = sumti5
	/ pcon:gek s1:sumti b:gik s2:sumti4 -> { ConnectedSumti True (pcon b) s1 s2 [] }

sumti5 :: Sumti =
	s:sumti6 !relativeClauses -> {QAtom Nothing [] s}
	/ q:quantifier? s:sumti6 rels:relativeClauses?
	    -> {QAtom q (fromMaybe [] rels) s}
	/ q:quantifier sb:selbri KU? rels:relativeClauses?
	    -> {QSelbri q (fromMaybe [] rels) sb}

relativeClauses :: {[RelClause]}
	= r:relativeClause rs:(ZIhE r:relativeClause -> r)*
	    -> {(r:rs)}

relativeClause :: RelClause
	= "poi":NOI subs:subsentence KUhO? -> {Restrictive subs}
	/ "noi":NOI subs:subsentence KUhO? -> {Incidental subs}
	/ "goi":GOI t:term GEhU? -> {Assignment t}
	/ "ne":GOI t:term GEhU? -> {IncidentalGOI "ne" t}
	/ "no'u":GOI t:term GEhU? -> {IncidentalGOI "no'u" t}
	/ "pe":GOI t:term GEhU? -> {RestrictiveGOI "pe" t}
	/ "po'u":GOI t:term GEhU? -> {RestrictiveGOI "po'u" t}
	/ "po":GOI t:term GEhU? -> {RestrictiveGOI "po" t}
	/ "po'e":GOI t:term GEhU? -> {RestrictiveGOI "po'e" t}

sumti6 :: SumtiAtom
    = "la":LA s:CMENE -> {Name s}
    / "mi":KOhA -> {NonAnaphoricProsumti "mi"}
    / "do":KOhA -> {NonAnaphoricProsumti "do"}
    / "ko":KOhA -> {NonAnaphoricProsumti "ko"}
    / "ti":KOhA -> {NonAnaphoricProsumti "ti"}
    / "ta":KOhA -> {NonAnaphoricProsumti "ta"}
    / "tu":KOhA -> {NonAnaphoricProsumti "tu"}
    / "da":KOhA "xi":XI n:litnum -> {Variable n}
    / "da":KOhA -> {Variable 1}
    / "de":KOhA -> {Variable 2}
    / "di":KOhA -> {Variable 3}
    / "ke'a":KOhA "xi":XI n:litnum -> {RelVar n}
    / "ke'a":KOhA -> {RelVar 1}
    / "ce'u":KOhA "xi":XI n:litnum -> {LambdaVar n}
    / "ce'u":KOhA -> {LambdaVar 1}
    / "ri":KOhA -> {Ri}
    / "ko'a":KOhA "xi":XI n:litnum -> {Assignable n}
    / "ko'a":KOhA -> {Assignable 1}
    / "ko'e":KOhA -> {Assignable 2}
    / "ko'i":KOhA -> {Assignable 3}
    / "ko'o":KOhA -> {Assignable 4}
    / "ko'u":KOhA -> {Assignable 5}
    / "fo'a":KOhA -> {Assignable 6}
    / "fo'e":KOhA -> {Assignable 7}
    / "fo'i":KOhA -> {Assignable 8}
    / "fo'o":KOhA -> {Assignable 9}
    / "fo'u":KOhA -> {Assignable 10}
    / l:lerfuString -> {LerfuString l}
    / "zo'e":KOhA -> {Zohe}
    / g:(LA/LE) {(is,q,sb,rels,irels)}:sumtiTail KU? ->
	{Description g is q sb rels irels}
    / LU t:text1 LIhU? -> {Quote t}
    / ZO s:Valsi -> {Word s}

sumtiTail :: {(Maybe Sumti, Maybe Quantifier, Selbri, [RelClause])}
    = s:sumti6 srels:relativeClauses? {(q,sb,irels)}:sumtiTail1
	-> {(Just (QAtom Nothing (fromMaybe [] srels) s),q,sb,[],irels)}
    / rels:relativeClauses? {(q,sb,irels)}:sumtiTail1
	-> {(Nothing,q,sb,(fromMaybe [] rels),irels)}

sumtiTail1 :: {(Maybe Quantifier, Selbri, [RelClause])}
    = sb:selbri rels:relativeClauses?
	-> {(Nothing,sb,fromMaybe [] rels)}
    / q:quantifier? sb:selbri rels:relativeClauses?
	-> {(q,sb,fromMaybe [] rels)}

-- XXX: really ought to allow arbitrary PA
lerfuString :: {[Lerfu]} = c:lerfu cs:(lerfu / n:digit -> {show n !! 0})*
    -> {c:cs}
lerfu :: Lerfu
    = s:BY -> {s!!0}
    / PAUSE? v:Vowel PAUSE? Spacing? BU -> {v}

quantifier :: Quantifier = q:number BOI? -> q

number :: Quantifier
    = "ro":PA -> Forall
    / "su'o":PA -> Exists
    / n:litnum -> {Exactly n}

litnum :: Int
    = ds:digit+ -> {
	let calc [] = 0
	    calc (d:ds) = (10*calc ds) + d
        in calc (reverse ds)}

digit :: Int
    = "no":PA -> {0}
    / "pa":PA -> {1}
    / "re":PA -> {2}
    / "ci":PA -> {3}
    / "vo":PA -> {4}
    / "mu":PA -> {5}
    / "xa":PA -> {6}
    / "ze":PA -> {7}
    / "bi":PA -> {8}
    / "so":PA -> {9}


ek :: LogJboConnective = ln:NA?
	se:(SE)? conchar:ekA rn:NAI?
    -> { LogJboConnective (isNothing ln) 
		    (if (isJust se) && conchar=='u' then 'U' else conchar)
		    (isNothing rn) }

jek :: LogJboConnective = ln:NA?
	se:(SE)? conchar:jekJA rn:NAI?
    -> { LogJboConnective (isNothing ln) 
		    (if (isJust se) && conchar=='u' then 'U' else conchar)
		    (isNothing rn) }

gihek :: LogJboConnective = ln:NA?
	se:(SE)? conchar:gihekGIhA rn:NAI?
    -> { LogJboConnective (isNothing ln) 
		    (if (isJust se) && conchar=='u' then 'U' else conchar)
		    (isNothing rn) }

gek :: {Bool -> Connective}
    = se:(SE)? conchar:gekGA ln:NAI?
	-> { JboConnLog Nothing . LogJboConnective (isNothing ln) 
		    (if (isJust se) && conchar=='u' then 'U' else conchar) }
    / tag:tag gik -> { \_ -> JboConnLog (Just tag) (LogJboConnective True 'e' True) }
    -- / joik GI ->

guhek :: {Bool -> LogJboConnective} = se:(SE)? conchar:guhekGUhA ln:NAI?
    -> { LogJboConnective (isNothing ln) 
		    (if (isJust se) && conchar=='u' then 'U' else conchar) }

gik :: Bool = GI rn:NAI? -> { isNothing rn }

ekA :: Char = "a":A -> {'a'}
    / "e":A -> {'e'}
    / "o":A -> {'o'}
    / "u":A -> {'u'}
    -- / "ji":A

jekJA :: Char = "ja":JA -> {'a'}
    / "je":JA -> {'e'}
    / "jo":JA -> {'o'}
    / "ju":JA -> {'u'}

gihekGIhA :: Char = "gi'a":GIhA -> {'a'}
    / "gi'e":GIhA -> {'e'}
    / "gi'o":GIhA -> {'o'}
    / "gi'u":GIhA -> {'u'}

gekGA :: Char = "ga":GA -> {'a'}
    / "ge":GA -> {'e'}
    / "go":GA -> {'o'}
    / "gu":GA -> {'u'}

guhekGUhA :: Char = "gu'a":GUhA -> {'a'}
    / "gu'e":GUhA -> {'e'}
    / "gu'o":GUhA -> {'o'}
    / "gu'u":GUhA -> {'u'}

bridiTail :: BridiTail
    = bt1:bridiTail1 gihek:(lcon:gihek mtag:(tag)? KE bt2:bridiTail KEhE? tts:tailTerms ->
	{(JboConnLog mtag lcon, bt2, tts)} )?
	    -> {
		case gihek of Nothing -> bt1
			      Just (con, bt2, tts) ->
				  ConnectedBT con bt1 bt2 tts }

bridiTail1 :: BridiTail
    = bt:bridiTail2 giheks:_gihekbt*
    -> { foldl (\bt1 -> \(con,bt2,tts) ->
		    ConnectedBT con bt1 bt2 tts
		) bt giheks }
-- _gihekbt: helper for bridiTail1
_gihekbt :: {(Connective, BridiTail, [Term])}
    = lcon:gihek bt:bridiTail2 tts:tailTerms -> {(JboConnLog Nothing lcon, bt, tts)}

bridiTail2 :: BridiTail
    = bt1:bridiTail3
	gihek:(lcon:gihek mtag:(tag)? BO bt2:bridiTail2 tts:tailTerms -> {(JboConnLog mtag lcon,bt2,tts)})?
	    -> {
		case gihek of Nothing -> bt1
			      Just (con, bt2, tts) ->
				  ConnectedBT con bt1 bt2 tts }

bridiTail3 :: BridiTail
    = sb:selbri ts:tailTerms -> { BridiTail3 sb ts }
    / gs:gekSentence -> { GekSentence gs }

tailTerms :: {[Term]}
    = ts:terms? VAU? -> { fromMaybe [] ts }

selbri :: Selbri
    = "na":NA sb:selbri -> {Negated sb}
    / ("ja'a":NA -> {})? sb:selbri2 -> {Selbri2 sb}
    / tag:tag sb:selbri -> {TaggedSelbri tag sb}

selbri2 :: Selbri2
    = sb:selbri3 CO sb':selbri2 -> {SBInverted sb sb'}
    / sb:selbri3 -> {Selbri3 sb}

selbri3 :: Selbri3
    = sb:selbri3 sb':selbri4 -> {SBTanru sb sb'}
    / selbri4

selbri4 :: Selbri3
    = sb:selbri5 jekss:(_jeksbs)*
	-> { foldl (\sb1 -> \(con,sb2) -> ConnectedSB False con sb1 sb2) sb jekss }
-- _jeksbs: helper for selbri4
_jeksbs :: {(Connective, Selbri3)}
    = lcon:jek sb:selbri5 -> {(JboConnLog Nothing lcon,sb)}

selbri5 :: Selbri3
    = sb1:selbri6 jeks:( lcon:jek mtag:(tag)? BO sb:selbri5 -> {(JboConnLog mtag lcon,sb)} )?
	-> { if (isNothing jeks) then sb1
				 else (let Just (con,sb2) = jeks
				       in ConnectedSB False con sb1 sb2) }

-- XXX: we deviate from the official grammar by allowing only selbri3 rather
-- than arbitrary selbri in the first part of a guhek; this is to avoid
-- connecting inverted selbri to non-inverted selbri, the semantics of which
-- are unclear.
selbri6 :: Selbri3
    = tu:tanruUnit BO sb:selbri6 -> {SBTanru tu sb}
    / tanruUnit
    / pcon:guhek sb1:selbri3 b:gik sb2:selbri6
	-> { ConnectedSB True (JboConnLog Nothing $ pcon b) sb1 sb2 }

tanruUnit :: Selbri3
    = tu:tanruUnit CEI tu':tanruUnit1 -> {BridiBinding tu tu'}
    / tanruUnit1
tanruUnit1 :: Selbri3
    = tu:tanruUnit2 las:linkargs? -> {TanruUnit tu (fromMaybe [] las)}

tanruUnit2 :: TanruUnit2
    = bv:BRIVLA -> {TUBrivla bv}
    / KE sb:selbri3 KEhE? -> {TUSelbri3 sb}
    / n:convSE tu:tanruUnit2 -> {TUPermuted n tu}
    / g:GOhA -> {TUGOhA g}
    / q:number m:MOI -> {TUMoi q m}
    / ME s:sumti MEhU? -> {TUMe s}
    / a:NU ss:subsentence KEI? -> {TUAbstraction a ss}

linkargs :: {[Term]}
    = BE t:term ts:links? BEhO? -> {(t : (fromMaybe [] ts))}

links :: {[Term]}
    = BEI t:term ts:links? -> {(t : (fromMaybe [] ts))}

gekSentence :: GekSentence
    = pcon:gek s1:subsentence b:gik s2:subsentence tts:tailTerms
	-> { ConnectedGS (pcon b) s1 s2 tts }
	/ KE gs:gekSentence KEhE? -> gs
	/ NA gs:gekSentence -> {NegatedGS gs}

convSE :: Int
    = SE XI n:litnum -> n
    / "se":SE -> {2}
    / "te":SE -> {3}
    / "ve":SE -> {4}
    / "xe":SE -> {5}

tagFA :: Int
    = FA XI n:litnum -> n
    / "fa":FA -> {1}
    / "fe":FA -> {2}
    / "fi":FA -> {3}
    / "fo":FA -> {4}
    / "fu":FA -> {5}

tag :: Tag
    = tag:tag1 jekts:(_jektag)* ->
	{ foldl (\t1 -> \(con,t2) -> ConnectedTag con t1 t2) tag jekts }
-- _jektag: helper for tag
_jektag :: {(Connective, Tag)}
    = lcon:jek tag:tag1 -> {(JboConnLog Nothing lcon,tag)}

-- XXX: we use the relaxed tag grammar of xorxes' zasni gerna
tag1 :: Tag
    = dtus:decoratedTagUnit+ -> {DecoratedTagUnits dtus}
decoratedTagUnit :: DecoratedTagUnit
    = nahe:(NAhE)? se:(convSE)? tu:tagUnit nai:(NAI)? ->
	{ DecoratedTagUnit nahe se (isJust nai) tu }
tagUnit :: TagUnit
    = s:(PU / ZI / ZEhA / VA / VEhA / VIhA / CAhA) -> {TenseCmavo s}
    / s:BAI -> {BAI s}
    / m:(MOhI)? f:FAhA -> { FAhA (isJust m) f }
    / f:(FEhE)? q:number ROI -> { ROI (isJust f) q }
    / f:(FEhE)? s:(TAhE / ZAhO) -> { TAhE_ZAhO (isJust f) s }
    / FIhO s:selbri FEhU? -> { FIhO s }
    / CUhE -> { CUhE }
    / KI -> { KI }

free :: {()}
    = TO sentence (TOI->{()})? -> {()}

LojbanLetter :: Char = Consonant / Vowel / OtherLetter
nonConsonant :: Char = Vowel / OtherLetter

InitialPair :: String = "bl" /  "br" /  "cf" /  "ck" /  "cl" /  "cm" /  "cn" /  "cp" /  "cr" /  "ct" /  "dj" /  "dr" /  "dz" /  "fl" /  "fr" /  "gl" /  "gr" /  "jb" /  "jd" /  "jg" /  "jm" /  "jv" /  "kl" /  "kr" /  "ml" /  "mr" /  "pl" /  "pr" /  "sf" /  "sk" /  "sl" /  "sm" /  "sn" /  "sp" /  "sr" /  "st" /  "tc" /  "tr" /  "ts" /  "vl" /  "vr" /  "xl" /  "xr" /  "zb" /  "zd" /  "zg" /  "zm" /  "zv"
Vowel :: Char = c:Char &{c `elem` "aeiouy"} -> c
Consonant :: Char = c:Char &{c `elem` "bcdfgjklmnprstvxz"} -> c
OtherLetter :: Char = c:Char &{c `elem` "',"} -> c
VowelNotY :: Char = c:Char &{c `elem` "aeiou"} -> c
YChar :: Char = 'y'
TickChar :: Char = '\''

Space :: {()}	= " " -> { () }
		/ "\n" -> { () }

Spacing :: {()} = Space+

Valsi :: String = cs:LojbanLetter+ Spacing -> cs

CMENE :: String = PAUSE? ss:CMENEchunk+ PAUSE? Spacing -> {foldl (++) [] ss}
CMENEchunk :: String = ls:nonConsonant* c:Consonant -> {ls++[c]}

PAUSE :: String = "."

BRIVLA :: String = 
	    a:InitialPair b:LojbanLetter c:LojbanLetter r:BRIVLATail -> {a++(b:c:r)}
	  / a:Consonant !YChar b:Vowel c:Consonant d:(YChar?) 
	      e:Consonant r:BRIVLATail 
		  -> { case d of {Just d -> (a:b:c:d:e:r); Nothing -> (a:b:c:e:r)} }
	  / a:Consonant !YChar b:Vowel c:(TickChar?) !YChar
	      d:Vowel e:Consonant f:Consonant r:BRIVLATail
		  -> { case c of {Just c -> (a:b:c:d:e:f:r); Nothing -> (a:b:d:e:f:r)} }

BRIVLATail :: String = 
	       a:VowelNotY !LojbanLetter Spacing -> { [a] }
	     / a:LojbanLetter r:BRIVLATail -> { (a:r) }

--         eks; basic afterthought logical connectives 
A :: String = s:Amain Spacing -> s
Amain :: String = "a" / "e" / "ji" / "o" / "u" 

--         modal operators 
BAI :: String = s:BAImain Spacing -> s
BAImain :: String = "du'o" / "si'u" / "zau" / "ki'i" / "du'i" / "cu'u" / "tu'i" / "ti'u" / "di'o" / "ji'u" / "ri'a" / "ni'i" / "mu'i" / "ki'u" / "va'u" / "koi" / "ca'i" / "ta'i" / "pu'e" / "ja'i" / "kai" / "bai" / "fi'e" / "de'i" / "ci'o" / "mau" / "mu'u" / "ri'i" / "ra'i" / "ka'a" / "pa'u" / "pa'a" / "le'a" / "ku'u" / "tai" / "bau" / "ma'i" / "ci'e" / "fau" / "po'i" / "cau" / "ma'e" / "ci'u" / "ra'a" / "pu'a" / "li'e" / "la'u" / "ba'i" / "ka'i" / "sau" / "fa'e" / "be'i" / "ti'i" / "ja'e" / "ga'a" / "va'o" / "ji'o" / "me'a" / "do'e" / "ji'e" / "pi'o" / "gau" / "zu'e" / "me'e" / "rai" 
--         next word intensifier 
BAhE :: String = s:BAhEmain Spacing -> s
BAhEmain :: String = "ba'e"
	/ "za'e" 
--         sumti link to attach sumti to a selbri 
BE :: String = s:BEmain Spacing -> s
BEmain :: String = "be" 
--         multiple sumti separator between BE, BEI 
BEI :: String = s:BEImain Spacing -> s
BEImain :: String = "bei" 
--         terminates BEBEI specified descriptors 
BEhO :: String = s:BEhOmain Spacing -> s
BEhOmain :: String = "be'o" 
--         prefix for high-priority MEX operator 
BIhE :: String = s:BIhEmain Spacing -> s
BIhEmain :: String = "bi'e" 
--         interval component of JOI 
BIhI :: String = s:BIhImain Spacing -> s
BIhImain :: String = "mi'i"
	/ "bi'o"
	/ "bi'i" 
--         joins two units with shortest scope 
BO :: String = s:BOmain Spacing -> s
BOmain :: String = "bo"
--         number or lerfu-string terminator 
BOI :: String = s:BOImain Spacing -> s
BOImain :: String = "boi" 
--         turns any word into a BY lerfu word 
BU :: String = s:BUmain Spacing -> s
BUmain :: String = "bu" 
--         individual lerfu words 
BY :: String = s:BYmain Spacing -> s
BYmain :: String = "jo'o" / "ru'o" / "ge'o" / "je'o" / "lo'a" / "na'a" / "se'e" / "to'a" / "ga'e" / "y'y" / "by" / "cy" / "dy" / "fy" / "gy" / "jy" / "ky" / "ly" / "my" / "ny" / "py" / "ry" / "sy" / "ty" / "vy" / "xy" / "zy" 

--         specifies actualitypotentiality of tense 
CAhA :: String = s:CAhAmain Spacing -> s
CAhAmain :: String = "ca'a" / "pu'i" / "nu'o" / "ka'e" 
--         afterthought intensity marker 
CAI :: String = s:CAImain Spacing -> s
CAImain :: String = "pei" / "cai" / "cu'i" / "sai" / "ru'e" 
--         pro-bridi assignment operator 
CEI :: String = s:CEImain Spacing -> s
CEImain :: String = "cei" 
--         afterthought term list connective 
CEhE :: String = s:CEhEmain Spacing -> s
CEhEmain :: String = "ce'e" 
--         names; require consonant end, then pause no
--                                    LA or DOI selma'o embedded, pause before if
--                                    vowel initial and preceded by a vowel 
--         tanru inversion  
CO :: String = s:COmain Spacing -> s
COmain :: String = "co" 
COI :: String = s:COImain Spacing -> s
COImain :: String = "ju'i" / "coi" / "fi'i" / "ta'a" / "mu'o" / "fe'o" / "co'o" / "pe'u" / "ke'o" / "nu'e" / "re'i" / "be'e" / "je'e" / "mi'e" / "ki'e" / "vi'o"
--         vocative marker permitted inside names; must
--                                    always be followed by pause or DOI 
--         separator between head sumti and selbri 
CU :: String = s:CUmain Spacing -> s
CUmain :: String = "cu" 
--         tensemodal question 
CUhE :: String = s:CUhEmain Spacing -> s
CUhEmain :: String = "cu'e" / "nau" 

--         cancel anaphoracataphora assignments 
DAhO :: String = s:DAhOmain Spacing -> s
DAhOmain :: String = "da'o" 
--         vocative marker 
DOI :: String = s:DOImain Spacing -> s
DOImain :: String = "doi" 
--         terminator for DOI-marked vocatives 
DOhU :: String = s:DOhUmain Spacing -> s
DOhUmain :: String = "do'u" 

--         modifier head generic case tag 
FA :: String = s:FAmain Spacing -> s
FAmain :: String = "fa" / "fe" / "fi" / "fo" / "fu" / "fai" / "fi'a" 
--         superdirections in space 
FAhA :: String = s:FAhAmain Spacing -> s
FAhAmain :: String = "du'a" / "be'a" / "ne'u" / "vu'a" / "ga'u" / "ti'a" / "ni'a" / "ca'u" / "zu'a" / "ri'u" / "ru'u" / "re'o" / "te'e" / "bu'u" / "ne'a" / "pa'o" / "ne'i" / "to'o" / "zo'i" / "ze'o" / "zo'a" / "fa'a" 
FAhO :: String = s:FAhOmain Spacing -> s
FAhOmain :: String = "fa'o"
--         normally elided 'done pause' to indicate end
--                                    of utterance string 
--         space interval mod flag 
FEhE :: String = s:FEhEmain Spacing -> s
FEhEmain :: String = "fe'e" 
--         ends bridi to modal conversion 
FEhU :: String = s:FEhUmain Spacing -> s
FEhUmain :: String = "fe'u" 
--         marks bridi to modal conversion 
FIhO :: String = s:FIhOmain Spacing -> s
FIhOmain :: String = "fi'o" 
--         end compound lerfu 
FOI :: String = s:FOImain Spacing -> s
FOImain :: String = "foi" 
--         reverse Polish flag 
FUhA :: String = s:FUhAmain Spacing -> s
FUhAmain :: String = "fu'a" 
--         open long scope for indicator 
FUhE :: String = s:FUhEmain Spacing -> s
FUhEmain :: String = "fu'e" 
--         close long scope for indicator 
FUhO :: String = s:FUhOmain Spacing -> s
FUhOmain :: String = "fu'o" 

--         geks; forethought logical connectives 
GA :: String = s:GAmain Spacing -> s
GAmain :: String = "ge" / "ge'i" / "go" / "ga" / "gu" 
--         openclosed interval markers for BIhI 
GAhO :: String = s:GAhOmain Spacing -> s
GAhOmain :: String = "ke'i" / "ga'o" 
--         marker ending GOI relative clauses 
GEhU :: String = s:GEhUmain Spacing -> s
GEhUmain :: String = "ge'u" 
--         forethought medial marker 
GI :: String = s:GImain Spacing -> s
GImain :: String = "gi"   
--         logical connectives for bridi-tails 
GIhA :: String = s:GIhAmain Spacing -> s
GIhAmain :: String = "gi'e" / "gi'i" / "gi'o" / "gi'a" / "gi'u" 
--         attaches a sumti modifier to a sumti 
GOI :: String = s:GOImain Spacing -> s
GOImain :: String = "no'u" / "ne" / "goi" / "po'u" / "pe" / "po'e" / "po"
--         pro-bridi 
GOhA :: String = s:GOhAmain Spacing -> s
GOhAmain :: String = "mo" / "nei" / "go'u" / "go'o" / "go'i" / "no'a" / "go'e" / "go'a" / "du" / "bu'a" / "bu'e" / "bu'i" / "co'e" 
--         GEK for tanru units, corresponds to JEKs 
GUhA :: String = s:GUhAmain Spacing -> s
GUhAmain :: String = "gu'e" / "gu'i" / "gu'o" / "gu'a" / "gu'u" 

--         sentence link 
I :: String = s:Imain Spacing -> s
Imain :: String = "i" 

--         jeks; logical connectives within tanru 
JA :: String = s:JAmain Spacing -> s
JAmain :: String = "je'i" / "je" / "jo" / "ja" / "ju" 
--         modal conversion flag 
JAI :: String = s:JAImain Spacing -> s
JAImain :: String = "jai" 
--         flags an array operand 
JOhI :: String = s:JOhImain Spacing -> s
JOhImain :: String = "jo'i" 
--         non-logical connectives 
JOI :: String = s:JOImain Spacing -> s
JOImain :: String = "fa'u" / "pi'u" / "joi" / "ce'o" / "ce" / "jo'u" / "ku'a" / "jo'e" / "ju'e" 

--         left long scope marker 
KE :: String = s:KEmain Spacing -> s
KEmain :: String = "ke" 
--         right terminator for KE groups 
KEhE :: String = s:KEhEmain Spacing -> s
KEhEmain :: String = "ke'e" 
--         right terminator, NU abstractions 
KEI :: String = s:KEImain Spacing -> s
KEImain :: String = "kei" 
--         multiple utterance scope for tenses 
KI :: String = s:KImain Spacing -> s
KImain :: String = "ki" 
--         sumti anaphora 
KOhA :: String = s:KOhAmain Spacing -> s
KOhAmain :: String = "da" / "de" / "di" / "da'u" / "da'e" / "di'u" / "di'e" / "de'u" / "de'e" / "dei" / "do'i" / "mi" / "mi'o" / "ma'a" / "mi'a" / "do" / "do'o" / "ko'a" / "fo'u" / "ko'e" / "ko'i" / "ko'o" / "ko'u" / "fo'a" / "fo'e" / "fo'i" / "fo'o" / "vo'a" / "vo'e" / "vo'i" / "vo'o" / "vo'u" / "ru" / "ri" / "ra" / "ta" / "tu" / "ti" / "zi'o" / "ke'a" / "ma" / "zu'i" / "zo'e" / "ce'u" / "ko"
--         right terminator for descriptions, etc. 
KU :: String = s:KUmain Spacing -> s
KUmain :: String = "ku" 
--         MEX forethought delimiter 
KUhE :: String = s:KUhEmain Spacing -> s
KUhEmain :: String = "ku'e" 
--         right terminator, NOI relative clauses 
KUhO :: String = s:KUhOmain Spacing -> s
KUhOmain :: String = "ku'o" 

--         name descriptors 
LA :: String = s:LAmain Spacing -> s
LAmain :: String = "la" / "lai" / "la'i" 
--         lerfu prefixes 
LAU :: String = s:LAUmain Spacing -> s
LAUmain :: String = "ce'a" / "lau" / "zai" / "tau" 
--         sumti qualifiers 
LAhE :: String = s:LAhEmain Spacing -> s
LAhEmain :: String = "tu'a" / "lu'a" / "lu'o" / "la'e" / "vu'i" / "lu'i" / "lu'e" 
--         sumti descriptors 
LE :: String = s:LEmain Spacing -> s
LEmain :: String =  "le'i" / "lo'i" / "le'e" / "lo'e" / "le" / "lei" / "loi" / "lo"
--         possibly ungrammatical text right quote 
LEhU :: String = s:LEhUmain Spacing -> s
LEhUmain :: String = "le'u" 
--         convert number to sumti 
LI :: String = s:LImain Spacing -> s
LImain :: String = "me'o"
	/ "li" 
--         grammatical text right quote 
LIhU :: String = s:LIhUmain Spacing -> s
LIhUmain :: String = "li'u" 
--         elidable terminator for LI 
LOhO :: String = s:LOhOmain Spacing -> s
LOhOmain :: String = "lo'o" 
--         possibly ungrammatical text left quote 
LOhU :: String = s:LOhUmain Spacing -> s
LOhUmain :: String = "lo'u" 
--         grammatical text left quote 
LU :: String = s:LUmain Spacing -> s
LUmain :: String = "lu" 
--         LAhE close delimiter 
LUhU :: String = s:LUhUmain Spacing -> s
LUhUmain :: String = "lu'u" 

--         change MEX expressions to MEX operators 
MAhO :: String = s:MAhOmain Spacing -> s
MAhOmain :: String = "ma'o" 
--         change numbers to utterance ordinals 
MAI :: String = s:MAImain Spacing -> s
MAImain :: String = "mo'o"
	/ "mai" 
--         converts a sumti into a tanru_unit 
ME :: String = s:MEmain Spacing -> s
MEmain :: String = "me" 
--         terminator for ME 
MEhU :: String = s:MEhUmain Spacing -> s
MEhUmain :: String = "me'u" 
--         change sumti to operand, inverse of LI 
MOhE :: String = s:MOhEmain Spacing -> s
MOhEmain :: String = "mo'e" 
--         motion tense marker 
MOhI :: String = s:MOhImain Spacing -> s
MOhImain :: String = "mo'i" 
--         change number to selbri 
MOI :: String = s:MOImain Spacing -> s
MOImain :: String = "mei" / "moi" / "si'e" / "cu'o" / "va'e" 

--         bridi negation  
NA :: String = s:NAmain Spacing -> s
NAmain :: String = "ja'a"
	/ "na" 
--         attached to words to negate them 
NAI :: String = s:NAImain Spacing -> s
NAImain :: String = "nai" 
--         scalar negation  
NAhE :: String = s:NAhEmain Spacing -> s
NAhEmain :: String = "to'e" / "je'a" / "na'e" / "no'e" 
--         change a selbri into an operator 
NAhU :: String = s:NAhUmain Spacing -> s
NAhUmain :: String = "na'u" 
--         change selbri to operand; inverse of MOI 
NIhE :: String = s:NIhEmain Spacing -> s
NIhEmain :: String = "ni'e" 
--         new paragraph; change of subject 
NIhO :: String = s:NIhOmain Spacing -> s
NIhOmain :: String = "ni'o" / "no'i" 
--         attaches a subordinate clause to a sumti 
NOI :: String = s:NOImain Spacing -> s
NOImain :: String = "voi" / "noi" / "poi" 
--         abstraction  
NU :: String = s:NUmain Spacing -> s
NUmain :: String = "ni" / "du'u" / "si'o" / "nu" / "li'i" / "ka" / "jei" / "su'u" / "zu'o" / "mu'e" / "pu'u" / "za'i" / "poi'i"
--         change operator to selbri; inverse of MOhE 
NUhA :: String = s:NUhAmain Spacing -> s
NUhAmain :: String = "nu'a" 
--         marks the start of a termset 
NUhI :: String = s:NUhImain Spacing -> s
NUhImain :: String = "nu'i" 
--         marks the middle and end of a termset 
NUhU :: String = s:NUhUmain Spacing -> s
NUhUmain :: String = "nu'u" 

--         numbers and numeric punctuation 
PA :: String = s:PAmain Spacing -> s
PAmain :: String = "no" / "pa" / "re" / "ci" / "vo" / "mu" / "xa" / "ze" / "bi" / "so" / "dau" / "fei" / "gai" / "jau" / "rei" / "vai" / "pi" / "pi'e" / "fi'u" / "za'u" / "me'i" / "ni'u" / "ki'o" / "ce'i" / "ma'u" / "ra'e" / "da'a" / "so'a" / "ji'i" / "su'o" / "su'e" / "ro" / "rau" / "so'u" / "so'i" / "so'e" / "so'o" / "mo'a" / "du'e" / "te'o" / "ka'o" / "ci'i" / "tu'o" / "xo" / "pai" / "no'o" 
--         afterthought termset connective prefix 
PEhE :: String = s:PEhEmain Spacing -> s
PEhEmain :: String = "pe'e" 
--         forethought (Polish) flag 
PEhO :: String = s:PEhOmain Spacing -> s
PEhOmain :: String = "pe'o" 
--         directions in time 
PU :: String = s:PUmain Spacing -> s
PUmain :: String = "ba" / "pu" / "ca" 

--         flag for modified interpretation of GOhI 
RAhO :: String = s:RAhOmain Spacing -> s
RAhOmain :: String = "ra'o" 
--         converts number to extensional tense 
ROI :: String = s:ROImain Spacing -> s
ROImain :: String = "re'u"
	/ "roi" 

SA :: String = s:SAmain Spacing -> s
SAmain :: String = "sa"
--         metalinguistic eraser to the beginning of
--                                    the current utterance 
--         conversions 
SE :: String = s:SEmain Spacing -> s
SEmain :: String = "se" / "te" / "ve" / "xe" 
--         metalinguistic bridi insert marker 
SEI :: String = s:SEImain Spacing -> s
SEImain :: String = "sei"
	/ "ti'o" 
--         metalinguistic bridi end marker 
SEhU :: String = s:SEhUmain Spacing -> s
SEhUmain :: String = "se'u" 
--         metalinguistic single word eraser 
SI :: String = s:SImain Spacing -> s
SImain :: String = "si" 
--         reciprocal sumti marker 
SOI :: String = s:SOImain Spacing -> s
SOImain :: String = "soi" 
--         metalinguistic eraser of the entire text 
SU :: String = s:SUmain Spacing -> s
SUmain :: String = "su" 

--         tense interval properties 
TAhE :: String = s:TAhEmain Spacing -> s
TAhEmain :: String = "ru'i" / "ta'e" / "di'i" / "na'o" 
--         closing gap for MEX constructs 
TEhU :: String = s:TEhUmain Spacing -> s
TEhUmain :: String = "te'u" 
--         start compound lerfu 
TEI :: String = s:TEImain Spacing -> s
TEImain :: String = "tei" 
--         left discursive parenthesis 
TO :: String = s:TOmain Spacing -> s
TOmain :: String = "to'i" / "to" 
--         right discursive parenthesis 
TOI :: String = s:TOImain Spacing -> s
TOImain :: String = "toi" 
--         multiple utterance scope mark 
TUhE :: String = s:TUhEmain Spacing -> s
TUhEmain :: String = "tu'e" 
--         multiple utterance end scope mark 
TUhU :: String = s:TUhUmain Spacing -> s
TUhUmain :: String = "tu'u" 

--         attitudinals, observationals, discursives 
UI :: String = s:UImain Spacing -> s
UImain :: String = "i'a" / "ie" / "a'e" / "u'i" / "i'o" / "i'e" / "a'a" / "ia" / "o'i" / "o'e" / "e'e" / "oi" / "uo" / "e'i" / "u'o" / "au" / "ua" / "a'i" / "i'u" / "ii" / "u'a" / "ui" / "a'o" / "ai" / "a'u" / "iu" / "ei" / "o'o" / "e'a" / "uu" / "o'a" / "o'u" / "u'u" / "e'o" / "io" / "e'u" / "ue" / "i'i" / "u'e" / "ba'a" / "ja'o" / "ca'e" / "su'a" / "ti'e" / "ka'u" / "se'o" / "za'a" / "pe'i" / "ru'a" / "ju'a" / "ta'o" / "ra'u" / "li'a" / "ba'u" / "mu'a" / "do'a" / "to'u" / "va'i" / "pa'e" / "zu'u" / "sa'e" / "la'a" / "ke'u" / "sa'u" / "da'i" / "je'u" / "sa'a" / "kau" / "ta'u" / "na'i" / "jo'a" / "bi'u" / "li'o" / "pau" / "mi'u" / "ku'i" / "ji'a" / "si'a" / "po'o" / "pe'a" / "ro'i" / "ro'e" / "ro'o" / "ro'u" / "ro'a" / "re'e" / "le'o" / "ju'o" / "fu'i" / "dai" / "ga'i" / "zo'o" / "be'u" / "ri'e" / "se'i" / "se'a" / "vu'e" / "ki'a" / "xu" / "ge'e" / "bu'o" 

--         distance in space-time 
VA :: String = s:VAmain Spacing -> s
VAmain :: String = "vi" / "va" / "vu" 
--         end simple bridi or bridi-tail 
VAU :: String = s:VAUmain Spacing -> s
VAUmain :: String = "vau" 
--         left MEX bracket 
VEI :: String = s:VEImain Spacing -> s
VEImain :: String = "vei" 
--         right MEX bracket 
VEhO :: String = s:VEhOmain Spacing -> s
VEhOmain :: String = "ve'o" 
--         MEX operator 
VUhU :: String = s:VUhUmain Spacing -> s
VUhUmain :: String = "ge'a" / "fu'u" / "pi'i" / "fe'i" / "vu'u" / "su'i" / "ju'u" / "gei" / "pa'i" / "fa'i" / "te'a" / "cu'a" / "va'a" / "ne'o" / "de'o" / "fe'a" / "sa'o" / "re'a" / "ri'o" / "sa'i" / "pi'a" / "si'i" 
--         space-time interval size 
VEhA :: String = s:VEhAmain Spacing -> s
VEhAmain :: String = "ve'u" / "ve'a" / "ve'i" / "ve'e" 
--         space-time dimensionality marker 
VIhA :: String = s:VIhAmain Spacing -> s
VIhAmain :: String = "vi'i" / "vi'a" / "vi'u" / "vi'e" 
VUhO :: String = s:VUhOmain Spacing -> s
VUhOmain :: String = "vu'o"
--         glue between logically connected sumti
--                                     and relative clauses 

--         subscripting operator 
XI :: String = s:XImain Spacing -> s
XImain :: String = "xi" 

--         hesitation 
Y :: String = s:Ymain Spacing -> s
Ymain :: String = "y" 

--         event properties - inchoative, etc. 
ZAhO :: String = s:ZAhOmain Spacing -> s
ZAhOmain :: String = "co'i" / "pu'o" / "co'u" / "mo'u" / "ca'o" / "co'a" / "de'a" / "ba'o" / "di'a" / "za'o" 
--         time interval size tense 
ZEhA :: String = s:ZEhAmain Spacing -> s
ZEhAmain :: String = "ze'u" / "ze'a" / "ze'i" / "ze'e" 
--         lujvo glue 
ZEI :: String = s:ZEImain Spacing -> s
ZEImain :: String = "zei" 
--         time distance tense 
ZI :: String = s:ZImain Spacing -> s
ZImain :: String = "zu" / "za" / "zi" 
--         conjoins relative clauses 
ZIhE :: String = s:ZIhEmain Spacing -> s
ZIhEmain :: String = "zi'e" 
--         single word metalinguistic quote marker 
ZO :: String = s:ZOmain Spacing -> s
ZOmain :: String = "zo" 
--         delimited quote marker 
ZOI :: String = s:ZOImain Spacing -> s
ZOImain :: String = "zoi" / "la'o" 
--         prenex terminator (not elidable) 
ZOhU :: String = s:ZOhUmain Spacing -> s
ZOhUmain :: String = "zo'u" 


{

eval :: String -> Either [Statement] Int
eval str = case tersmuatext1 (tersmuParse "atext1" (str ++ " ")) of
-- eval :: String -> Sumti
-- eval str = case tersmuterm (tersmuParse "term" str) of
-- eval :: String -> String
-- eval str = case tersmuCMENE (tersmuParse "CMENE" str) of
-- eval :: String -> Char
-- eval str = case tersmuLojbanLetter (tersmuParse "LojbanLetter" str) of
	Parsed p _ _ -> Left p
	NoParse e -> Right (posCol (errorPos e))
}
