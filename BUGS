All known divergence from CLL prescription, or from plausible interpretations
thereof, is noted here.

Definite bugs:
    ka can't handle multiple ce'u (should return a relation)

    Only the simplest {goi} phrases, those of the form {[sumti] goi ko'a}, are
    currently handled.

Probably bugs:
    Current gadri (non)-handling is probably inconsistent with xorlo.

    We don't handle donkey anaphora, and so are not in accordance with the
    CLL. For example, we have
	> ro ponse be su'o xasli cu darxi ri
	Prop:FA x1:(EX x2:(xasli(_)). ponse(_,x2)). darxi(x1,x1)
    , which contradicts CLL:7.6.

    We have the first part of a guhek being a selbri3 rather than an arbitrary
    selbri. That's because I don't see a sensible way to deal with things like
    {gu'e broda co brode gi brodi ko'a}

Possibly bugs:
    Quantifiers on bound variables are ignored. This is contrary to
    CLL:16.14.1-2. But I don't see how to make sense of what's specified
    there.

    Seltau are considered to be unary predicates rather than higher arity
    relations.

    According to CLL:16.11.14, bridi negation scopes over the prenex... but I
    don't see how to sensibly extend that to arbitrary statements, so I'm
    ignoring it.
    c.f. http://www.lojban.org/tiki/BPFK+Section%3A+brivla+Negators and links
    therefrom.
    Meanwhile, that BPFK section on brivla negation currently states that {na}
    "has scope over quantifiers that follow". Currently that's how I have
    {na ku} working, but not bare {na}.

    We have {broda gi'e brode vau da} equiv to {broda da gi'e brode da};
    similarly for JA-connected selbri. I'm not sure whether this is right, nor
    whether there's a coherent alternative. (I suppose the alternative would
    have to be to handle these tailterms with an 'append' which appends the
    result to the tails of all the connected bridi it's a tailterm of. I don't
    currently see why this couldn't work, but haven't thought it through.)

    Termset quantification: CLL:16.7.5 has quantifiers in the same termset
    having "equal scope", but I don't understand what this means.

    We treat {broda zo'e goi ko'a ko'a} as equivalent to {broda zo'e zo'e}.

Probably not bugs:
    This might at first seem wrong:
	> na ku mi noi brode cu broda
	Prop:!(brode(mi) /\ broda(mi))
    but consider that e.g.
	> na ku da ro broda be da ku noi brodi cu brodu
	Prop:!EX x1. FA x2:(broda(_,x1)). (brodu(x1,x2) /\ brodi(x2))
    is probably right.

    Also,
	> ro da na ku broda .i je de brode
	Prop:FA x1. !EX x2. (broda(x1) /\ brode(x2))
    is right, because
    	> ro da na ku broda de .i je de brode
	Prop:FA x1. !EX x2. (broda(x1,x2) /\ brode(x2))
    has to be; c.f.
	> ro da na broda de .i je de brode
	Prop:FA x1. EX x2. (!broda(x1,x2) /\ brode(x2)) .
