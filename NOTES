First goal: handle the "first order fragment" of lojban

Handling quantifiers:
    binding happens where a prenex is or could be, i.e. at 'statement' and at
    'subsentence'.

    This means that an unbound da gets exported to the innermost such prenex,
    and binds just within the corresponding statement/subsentence.

    Handling exportation may be a little complicated... for rather similar
    reasons that handling 'ri' et al will be - the semantics of lojban is
    partly a matter of the partial order of the parse tree, but partly of the
    (cross-level) total order of occurance in the text.

    This actually fits the State Monad approach quite well...

Naive algorithm:
    (Using a monad,) build up a prenex as we parse a statement/subsentence.
    Every time we hit a currently unbound da, or a naku, or a tense/modal, we
    add it to the end of the prenex.

    Problem with this: it doesn't correctly handle the interaction between
    sumti connectives and negation - CLL explicitly states (16.12.10-11) that
    {ge xy gi zy na ku} == {na ku ga xy gi zy}. Presumably tenses and unbound
    da should be handled analogously.

Idea:
    Treat sumti connectives just like quantifiers.
    x .e y broda == \forall z \in {x,y}. z broda == z=(x and y). z broda
    sim
    x .o y broda == z=(x iff y). z broda

    Semantics the obvious ones.

    We could even add such quantifiers to handle termsets.

    So now all is clear.

    We have:
    data QT = Arglist [Obj]
	      | Negation QT
	      | Quantifier Number (Obj -> QT)
	      | Connective TruthTable (Obj -> Obj -> QT)
	      | Tag Tag Ojbect QT
    type QuantifiedTerms = QT
    data TermCxt = {QT::QT, lastFA::Nat}
    Term :: TermCxt -> TermCxt
    
    Actually, this is useless: can't even handle {A .a B .e C .a bo D}.

    Instead, how about we just: have a ComplexSumti type, and have 'term'
    initially return that; then make exporting to the prenex a step which
    comes later. So the initial parsing returns something closely tied to the
    lojban, and the hard work converting that to logic is done separately.

    Remaining complexities:
	{su'o broda be da} -> {da de poi broda da}

	Tenses and modals are of quantificatory nature (sometimes inherently
	(ta'e, ro roi), and always if JA-connected), so should go in the
	prenex.

