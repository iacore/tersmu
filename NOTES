First goal: handle the "first order fragment" of lojban

Handling quantifiers:
    binding happens where a prenex is or could be, i.e. at 'statement' and at
    'subsentence'.

    This means that an unbound da gets exported to the innermost such prenex,
    and binds just within the corresponding statement/subsentence.

    Handling exportation may be a little complicated... for rather similar
    reasons that handling 'ri' et al will be - the semantics of lojban is
    partly a matter of the partial order of the parse tree, but partly of the
    (cross-level) total order of occurance in the text.

    This actually fits the State Monad approach quite well...

Naive algorithm:
    (Using a monad,) build up a prenex as we parse a statement/subsentence.
    Every time we hit a currently unbound da, or a naku, or a tense/modal, we
    add it to the end of the prenex.

    Problem with this: it doesn't correctly handle the interaction between
    sumti connectives and negation - CLL explicitly states (16.12.10-11) that
    {ge xy gi zy na ku} == {na ku ga xy gi zy}. Presumably tenses and unbound
    da should be handled analogously.

Idea:
    Treat sumti connectives just like quantifiers.
    x .e y broda == \forall z \in {x,y}. z broda == z=(x and y). z broda
    sim
    x .o y broda == z=(x iff y). z broda

    Semantics the obvious ones.

    We could even add such quantifiers to handle termsets.

    So now all is clear.

    We have:
    data QT = Arglist [Obj]
	      | Negation QT
	      | Quantifier Number (Obj -> QT)
	      | Connective TruthTable (Obj -> Obj -> QT)
	      | Tag Tag Ojbect QT
    type QuantifiedTerms = QT
    data TermCxt = {QT::QT, lastFA::Nat}
    Term :: TermCxt -> TermCxt
    
    Actually, this is useless: can't even handle {A .a B .e C .a bo D}.

    Instead, how about we just: have a ComplexSumti type, and have 'term'
    initially return that; then make exporting to the prenex a step which
    comes later. So the initial parsing returns something closely tied to the
    lojban, and the hard work converting that to logic is done separately.

    Remaining complexities:
	{su'o broda be da zo'u} -> {da de poi broda da zo'u}?

	Tenses and modals are of quantificatory nature (sometimes inherently
	(ta'e, ro roi), and always if JA-connected), so should go in the
	prenex.



Handling sumti:
    CLL seems to imply (ignoring masses):
	A sumti is a constant, and refers to one or more individuals
	    ('constant' can't be taken too literally - e.g. we may have a
	    quantified variable as a linkarg in a description sumti)
	poi narrows the referent-set of a sumti
	sumti always appear quantified
	we can consider bound {da} as special - it's a singular variable, so
	    quantifiers on it are meaningless.

	xorlo's modification (ignoring plural predication and Kinds etc):
	    lo has no default quantifier, and when unquantified is magic - it
		acts like it has a universal quantifier with tightest scope.
	    Moreover, {lo broda} refers to only *some* individuals which
		broda, not all.
	    So it acts much like {le} does, but with assertive power.

    Handling this in logic:
	Naive approach:
	    Translate to monadic second order:
		{le broda goi ko'a cu brode ko'a}
		    -> EX X. (describe(FA x\in X. broda(x)) /\
				FA x\in X. FA y\in X. brode(x,y))
		{lo broda goi ko'a cu brode ko'a}
		    -> EX X. (FA x. (broda(x) <-> x\in X) /\
				EX x\in X. FA y\in X. brode(x,y))

	But no need for second-order quantifiers really:
		{le broda goi ko'a cu brode ko'a}
		    -> FA x:(describe(broda(x)). 
			FA y:(describe(broda(y)). brode(x,y)

		{lo broda goi ko'a cu brode ko'a}
		    -> EX x:(broda(x)). FA y:(broda(y)). brode(x,y)

	    So we analyse e.g. {ko'a} as binding to a unary predicate rather
		than the corresponding set.

	    Issues with that:
	     The predicate might involve a bound variable
	      In which case, I suppose anaphora to the sumti should simply be
	      disallowed - or better, allowed only within the scope of the
	      quantifier.
	     The same description might have different referents on different
	     uses, whereas ko'a must bind to a single choice of referents.
	      So maybe second order quantification is necessary for {le} and
	      {voi} after all. So probably also for xorlo. Also for {la}.
	      Given which... is it actually worth the bother to handle {lo}
	      differently? Wouldn't it be better to translate to monadic 2nd
	      order, then have some proof theory which will do the reduction
	      to 1st order if we want it?

	Alternatively:
	 Nothing 2nd order. {le broda} and {la .brod.} are considered
	 *absolute* constants. {ro da le broda be da cu brode} is not allowed,
	 or is equiv to {ro da le broda be de cu brode}.

	 Getting goi working will be painful and monadic.

    Remark: if you think that using xorban style plural predication will make
    any of the above problems go away, think again, recalling that we still
    need to be able to quantify over atoms.
     
Plural semantics:
    Even sticking to CLL, some things seem to make a logic with plural terms
    and variables more natural. The closest things we have to basic terms -
    personal prosumti and le/la-clauses - are plural, and at least many
    anaphoric sumti are plural.

    So maybe we should translate to a plural logic, and from there to FOL by
    distributivity if we want?

    So it seems our intermediate logic would just be FOL with plural terms and
    an among relation? No need even for plural quantifiers?

    So we can actually just use FOL, with some unusual terms.

zo'e:
    Translating {lo broda} to {zo'e noi broda}, and {le} fa'u {voi}, seems
    better than considering it as a constant.

    So we should add zo'e to our logic?

    Can we just consider it as introducing an existential plural quantifier?

    {ro da zo'e} == {zo'e ro da}

    But {da zo'e noi broda da} != {zo'e noi broda da ku'o da}

    Some examples:
	{zo'e se fetsi ro mamta} == {ro mamta cu fetsi zo'e} ==
	{ro mamta cu fetsi da}

    So why not just have it as an *innermost* existential quantifier?

    To handle the 'obvious referents' interpretation of {zo'e} it seems we
    should actually interpret {zo'e} as an existential quantifier with
    tightest scope over a varying glorked domain.
    e.g. {ro da broda zo'e} -> \forall x. \exists y\in C_x. broda(x,y)

    With this definition of {zo'e}, {lo} == {zo'e noi} seems to explain many
    uses of {lo}. Often {lo} gives a Skolem function, corresponding to C_x
    being a singleton, but not always. e.g. if we don't want to resort to
    Kinds, {so'e re'azda cu se xabju lo jukni} really should translate as
    most h:house. \exists s:spider. dwells(s,h)
    (so with the constant glorked domain {s | spider(s)}).

    With multiple {zo'e}s, the domains have to be glorked simultaneously
    before any existential quantification - i.e. it's \exists (x,y) \in C, not
    \exists x\in C. \exists y \in C'_x  .

    This leaves only generics and kinds to deal with. I think my preference is
    to *not* allow {lo} to get at either - require {lo'e} for generics, and
    {lo ka} in place of kinds. But alternatively, we could allow \Gen in place
    of \exists as a possible quantifier for {zo'e}.

Handling descriptions and {zo'e} without really handling them:
    Just leave them as unanalysed terms. The terms will have structure which
    can be used in further analysis, but we consider this beyond the basic
    logic we deal with here.

    Note that the structure will sometimes mention bound variables, e.g. in
    {ro da lo broda be da cu brode}, but that's fine.

    Quantifiers we can handle by quantifying the "among [the term]" predicate.
    
    Relative clauses have I guess to be considered part of the term.

Two-stage interpretation:
    If we're willing to accept {lo} == {zo'e noi}, which I'm currently
	thinking we should be, we can proceed as follows:

    First stage: everything is reduced to predications, in particular worlds,
	of (possibly complicated) selbri with sumti being named entities or
	personal prosumti or bound variables or zo'e expressions (meaning zo'e
	+ relative clauses).

	i.e. we obtain something of type Prop Selbri JboTerm, where JboTerm
	has just those four constructors.

	Anaphora are resolved at this level. For zo'e expressions, anaphora
	bind "in intension" - i.e. to the zo'e clause as a whole; they
	therefore make sense anywhere in the scope of any variables which
	occur bound in the zo'e expression.
	
	(This means that e.g. {ro te cange poi ponse lo xasli cu darxi ri}
	doesn't really work - it becomes equivalent to {ro te cange poi ponse
	lo xasli cu darxi lo xasli}. But nevermind, at least for now.)

	The result of this first stage should be quite human-readable, and the
	derivation from the original text is likely to be fairly transparent.

    Second stage: zo'e expressions are replaced by existential/generic
	quantifiers as appropriate, with domains to be glorked, or (perhaps)
	by property predications. The result may not be so readable.

    Interpreting the final expression in a model (as part of a discourse) is
    potentially rather complicated, due to the glorking required. But we can
    null-glork, letting the domain always be the whole universe.


Quantified zo'e and relative clauses:
    Do the clauses apply to the zo'e itself or to atoms below it?

    ro lo broda poi brode -> (ro (zo'e noi broda)) zi'e poi brode
    but
    ro mi poi broda -> (ro mi) poi broda

    I think we should have this being a difference between poi and noi: poi
    takes only singular variables. {lo broda poi brode} is a type error.

Kinds/properties:
    xorxes wants kinds in the universe, distinct from properties, with
    {lo broda} (and hence {zo'e noi broda}) able to get a kind.

    I think this is evil, for various reasons.

    We can get approximately the same effect by making {lo broda} be ambiguous
    between {zo'e noi broda} and {zo'e noi ka broda}, while keeping zo'e sane
    (roughly: resolving as a plural existential or (maybe) generic quantifier)

Notes on lambdas:
    Currently, we're implementing lambdas expressions directly in Haskell,
    i.e. as function types. In FOL, we're using (Int -> Prop) rather than
    (Term -> Prop), whereas in Lojban.hs we're using (JboTerm -> JboProp).

    The use of Int in the former was to make it possible to do interpretation.

    The problem with using Int for the latter is that we actually do want to 
    apply them to JboTerms.

    But we run into problems when trying to interpret our JboProps - e.g. when
    interpreting tanru.

    Solution: introduce a constructor to Prop:
	    LambdaApp (Int -> Prop r t) t
	which is interpreted in a model in the obvious way - it just adds a
	binding.

The big idea:
    We reduce the problem of understanding (a fragment of) lojban to that of
    understanding
	(i) first order logic
	(ii) brivla and cmene and non-anaphoric pro-sumti
	(iii) tanru and NU-selbri
	(iv) zo'e-terms
    More precisely, we interpret a lojban sentence as a proposition in
    first-order logic with the things in (ii)-(iv) as the terms and relations.

    Here, a zo'e-term corresponds to an expression of the form
    {zo'e noi broda} (or just {zo'e}); it has the corresponding unary
    predicate (or nothing) as data.


