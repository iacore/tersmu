First goal: handle the "first order fragment" of lojban

Handling quantifiers:
    binding happens where a prenex is or could be, i.e. at 'statement' and at
    'subsentence'.

    This means that an unbound da gets exported to the innermost such prenex,
    and binds just within the corresponding statement/subsentence.

    Handling exportation may be a little complicated... for rather similar
    reasons that handling 'ri' et al will be - the semantics of lojban is
    partly a matter of the partial order of the parse tree, but partly of the
    (cross-level) total order of occurance in the text.

    This actually fits the State Monad approach quite well...

Naive algorithm:
    (Using a monad,) build up a prenex as we parse a statement/subsentence.
    Every time we hit a currently unbound da, or a naku, or a tense/modal, we
    add it to the end of the prenex.

    Problem with this: it doesn't correctly handle the interaction between
    sumti connectives and negation - CLL explicitly states (16.12.10-11) that
    {ge xy gi zy na ku} == {na ku ga xy gi zy}. Presumably tenses and unbound
    da should be handled analogously.

Idea:
    Treat sumti connectives just like quantifiers.
    x .e y broda == \forall z \in {x,y}. z broda == z=(x and y). z broda
    sim
    x .o y broda == z=(x iff y). z broda

    Semantics the obvious ones.

    We could even add such quantifiers to handle termsets.

    So now all is clear.

    We have:
    data QT = Arglist [Obj]
	      | Negation QT
	      | Quantifier Number (Obj -> QT)
	      | Connective TruthTable (Obj -> Obj -> QT)
	      | Tag Tag Ojbect QT
    type QuantifiedTerms = QT
    data TermCxt = {QT::QT, lastFA::Nat}
    Term :: TermCxt -> TermCxt
    
    Actually, this is useless: can't even handle {A .a B .e C .a bo D}.

    Instead, how about we just: have a ComplexSumti type, and have 'term'
    initially return that; then make exporting to the prenex a step which
    comes later. So the initial parsing returns something closely tied to the
    lojban, and the hard work converting that to logic is done separately.

    Remaining complexities:
	{su'o broda be da zo'u} -> {da de poi broda da zo'u}?

	Tenses and modals are of quantificatory nature (sometimes inherently
	(ta'e, ro roi), and always if JA-connected), so should go in the
	prenex.



Handling sumti:
    CLL seems to imply (ignoring masses):
	A sumti is a constant, and refers to one or more individuals
	    ('constant' can't be taken too literally - e.g. we may have a
	    quantified variable as a linkarg in a description sumti)
	poi narrows the referent-set of a sumti
	sumti always appear quantified
	we can consider bound {da} as special - it's a singular variable, so
	    quantifiers on it are meaningless.

	xorlo's modification (ignoring plural predication and Kinds etc):
	    lo has no default quantifier, and when unquantified is magic - it
		acts like it has a universal quantifier with tightest scope.
	    Moreover, {lo broda} refers to only *some* individuals which
		broda, not all.
	    So it acts much like {le} does, but with assertive power.

    Handling this in logic:
	Naive approach:
	    Translate to monadic second order:
		{le broda goi ko'a cu brode ko'a}
		    -> EX X. (describe(FA x\in X. broda(x)) /\
				FA x\in X. FA y\in X. brode(x,y))
		{lo broda goi ko'a cu brode ko'a}
		    -> EX X. (FA x. (broda(x) <-> x\in X) /\
				EX x\in X. FA y\in X. brode(x,y))

	But no need for second-order quantifiers really:
		{le broda goi ko'a cu brode ko'a}
		    -> FA x:(describe(broda(x)). 
			FA y:(describe(broda(y)). brode(x,y)

		{lo broda goi ko'a cu brode ko'a}
		    -> EX x:(broda(x)). FA y:(broda(y)). brode(x,y)

	    So we analyse e.g. {ko'a} as binding to a unary predicate rather
		than the corresponding set.

	    Issues with that:
	     The predicate might involve a bound variable
	      In which case, I suppose anaphora to the sumti should simply be
	      disallowed - or better, allowed only within the scope of the
	      quantifier.
	     The same description might have different referents on different
	     uses, whereas ko'a must bind to a single choice of referents.
	      So maybe second order quantification is necessary for {le} and
	      {voi} after all. So probably also for xorlo. Also for {la}.
	      Given which... is it actually worth the bother to handle {lo}
	      differently? Wouldn't it be better to translate to monadic 2nd
	      order, then have some proof theory which will do the reduction
	      to 1st order if we want it?

	Alternatively:
	 Nothing 2nd order. {le broda} and {la .brod.} are considered
	 *absolute* constants. {ro da le broda be da cu brode} is not allowed,
	 or is equiv to {ro da le broda be de cu brode}.

	 Getting goi working will be painful and monadic.

    Remark: if you think that using xorban style plural predication will make
    any of the above problems go away, think again, recalling that we still
    need to be able to quantify over atoms.
     
Plural semantics:
    Even sticking to CLL, some things seem to make a logic with plural terms
    and variables more natural. The closest things we have to basic terms -
    personal prosumti and le/la-clauses - are plural, and at least many
    anaphoric sumti are plural.

    So maybe we should translate to a plural logic, and from there to FOL by
    distributivity if we want?

    So it seems our intermediate logic would just be FOL with plural terms and
    an among relation? No need even for plural quantifiers?

